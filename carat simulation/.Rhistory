points(locations_distance, locations_cov_low, cex=0.4, col="red")
points(locations_distance, locations_cov_full, cex=0.4, col="green")
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_low, cex=0.4, col="red")
## exponential covariance function
expC <- function(h) exp(-3/50 * h)
## Input: two locations s1, s2
## output: covariance between s1 and s2
trueCovariance <- generateCovaiance(expC)
## knots S*
knots_num = 361
knots_matrix = as.matrix(expand.grid(seq(5, 95, 5),seq(5, 95, 5)))
## C* matrix of size m * m
C_star <- matrix(0, nrow = knots_num, ncol = knots_num)
for(i in 1:knots_num)
for(j in 1:knots_num)
C_star[i,j] = trueCovariance(knots_matrix[i,],knots_matrix[j,])
eigenvalues = eigen(C_star)$values
eigenvectors = eigen(C_star)$vectors
C_star_inv = solve(C_star)
## low rank approximation covariance function
C_low <- function(s1, s2) {
## low rank approximation
vecS1 = apply(knots_matrix, 1, trueCovariance, s1)
vecS2 = apply(knots_matrix, 1, trueCovariance, s2)
## return(t(vecS1) %*% solve(C_star,vecS2))
return(t(vecS1) %*% C_star_inv %*% vecS2)
}
## tapering
## spherical covariance function
sphericalK <- function(h, gamma) max(0,(1-h/gamma)^2) * (1+h/(2*gamma))
## full-scale approximation
C_l <- C_low
C_s <- function(s1, s2) {
(trueCovariance(s1, s2) - C_low(s1, s2)) * K(s1,s2, gamma = 20)
}
C_full <-  function(s1, s2) C_l(s1, s2) + C_s(s1, s2)
## simulation in Fig.1
locations = r2unif(500, c(0,100), c(0,100))
T = 3000
locations_distance = numeric(length = T)
locations_cov_low = numeric(length = T)
locations_cov_full = numeric(length = T)
s1 = 0;s2 = 0
for(t in 1:T) {
s1 = locations[runif(1, 0, 500), ]
s2 = locations[runif(1, 0, 500), ]
locations_distance[t] = sqrt(sum((s1 - s2)^2))
locations_cov_low[t] = C_l(s1, s2)
locations_cov_full[t] = C_full(s1, s2)
}
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_low, cex=0.4, col="red")
par(mfrow=c(1,2))
par(mfrow=c(1,2))
for(t in 1:T) {
s1 = locations[runif(1, 0, 500), ]
s2 = locations[runif(1, 0, 500), ]
locations_distance[t] = sqrt(sum((s1 - s2)^2))
locations_cov_low[t] = C_l(s1, s2)
locations_cov_full[t] = C_full(s1, s2)
}
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_low, cex=0.4, col="red")
## knots S*
knots_num = 100
knots_matrix = as.matrix(expand.grid(seq(5, 95, 10),seq(5, 95, 10)))
## C* matrix of size m * m
C_star <- matrix(0, nrow = knots_num, ncol = knots_num)
for(i in 1:knots_num)
for(j in 1:knots_num)
C_star[i,j] = trueCovariance(knots_matrix[i,],knots_matrix[j,])
eigenvalues = eigen(C_star)$values
eigenvectors = eigen(C_star)$vectors
C_star_inv = solve(C_star)
## low rank approximation covariance function
C_low <- function(s1, s2) {
## low rank approximation
vecS1 = apply(knots_matrix, 1, trueCovariance, s1)
vecS2 = apply(knots_matrix, 1, trueCovariance, s2)
## return(t(vecS1) %*% solve(C_star,vecS2))
return(t(vecS1) %*% C_star_inv %*% vecS2)
}
## tapering
## spherical covariance function
sphericalK <- function(h, gamma) max(0,(1-h/gamma)^2) * (1+h/(2*gamma))
## full-scale approximation
C_l <- C_low
C_s <- function(s1, s2) {
(trueCovariance(s1, s2) - C_low(s1, s2)) * K(s1,s2, gamma = 20)
}
C_full <-  function(s1, s2) C_l(s1, s2) + C_s(s1, s2)
## simulation in Fig.1
locations = r2unif(500, c(0,100), c(0,100))
T = 3000
locations_distance = numeric(length = T)
locations_cov_low = numeric(length = T)
locations_cov_full = numeric(length = T)
s1 = 0;s2 = 0
for(t in 1:T) {
s1 = locations[runif(1, 0, 500), ]
s2 = locations[runif(1, 0, 500), ]
locations_distance[t] = sqrt(sum((s1 - s2)^2))
locations_cov_low[t] = C_l(s1, s2)
locations_cov_full[t] = C_full(s1, s2)
}
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_low, cex=0.4, col="red")
par(mfrow=c(1,1))
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_low, cex=0.4, col="red")
points(locations_distance, locations_cov_full, cex=0.4, col="green")
## Compare C(h),C_l(h) and C_full(h)
h_matrix = expand.grid(50,0:35)
plot(0:35, apply(h_matrix, 1, trueCovariance, c(50,0)),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
lines(0:35, apply(h_matrix, 1, C_low, c(50,0)), col="red")
lines(0:35, apply(h_matrix, 1, C_full, c(50,0)), col="green")
####### Helper functions ########
r2unif <- function(n, range1, range2) {
## 2-d uniform randam vector
var1 = runif(n, range1[1],range1[2])
var2 = runif(n, range2[1],range2[2])
return(as.matrix(cbind(var1, var2)))
}
## exponential covariance function
expC <- function(h) exp(-3/50 * h)
generateCovaiance <- function(C) {
## generate an isotropic and stationary covariance function
f <- function(s1, s2) {
distance = sqrt(sum((s1-s2)^2))
return(C(distance))
}
}
## Input: two locations s1, s2
## output: covariance between s1 and s2
trueCovariance <- generateCovaiance(expC)
## knots S*
knots_num = 100
knots_matrix = as.matrix(expand.grid(seq(5, 95, 10),seq(5, 95, 10)))
## C* matrix of size m * m
C_star <- matrix(0, nrow = knots_num, ncol = knots_num)
for(i in 1:knots_num)
for(j in 1:knots_num)
C_star[i,j] = trueCovariance(knots_matrix[i,],knots_matrix[j,])
eigenvalues = eigen(C_star)$values
eigenvectors = eigen(C_star)$vectors
C_star_inv = solve(C_star)
####### Helper functions ########
r2unif <- function(n, range1, range2) {
## 2-d uniform randam vector
var1 = runif(n, range1[1],range1[2])
var2 = runif(n, range2[1],range2[2])
return(as.matrix(cbind(var1, var2)))
}
## exponential covariance function
expC <- function(h) exp(-3/50 * h)
generateCovaiance <- function(C) {
## generate an isotropic and stationary covariance function
f <- function(s1, s2) {
distance = sqrt(sum((s1-s2)^2))
return(C(distance))
}
}
## Input: two locations s1, s2
## output: covariance between s1 and s2
trueCovariance <- generateCovaiance(expC)
## knots S*
knots_num = 100
knots_matrix = as.matrix(expand.grid(seq(5, 95, 10),seq(5, 95, 10)))
## C* matrix of size m * m
C_star <- matrix(0, nrow = knots_num, ncol = knots_num)
for(i in 1:knots_num)
for(j in 1:knots_num)
C_star[i,j] = trueCovariance(knots_matrix[i,],knots_matrix[j,])
eigenvalues = eigen(C_star)$values
eigenvectors = eigen(C_star)$vectors
C_star_inv = solve(C_star)
## reduced rank approximation covariance function
C_reduced <- function(s1, s2) {
## reduced rank approximation
vecS1 = apply(knots_matrix, 1, trueCovariance, s1)
vecS2 = apply(knots_matrix, 1, trueCovariance, s2)
## return(t(vecS1) %*% solve(C_star,vecS2))
return(t(vecS1) %*% C_star_inv %*% vecS2)
}
## tapering
## spherical covariance function
sphericalK <- function(h, gamma) max(0,(1-h/gamma)^2) * (1+h/(2*gamma))
generateTapering <- function(K) {
## generate the tapering function
f <- function(s1, s2, gamma) {
distance = sqrt(sum((s1-s2)^2))
return(K(distance ,gamma))
}
}
K <- generateTapering(sphericalK)
## full-scale approximation
C_l <- C_reduced
C_s <- function(s1, s2) {
(trueCovariance(s1, s2) - C_reduced(s1, s2)) * K(s1,s2, gamma = 20)
}
C_full <-  function(s1, s2) C_l(s1, s2) + C_s(s1, s2)
## simulation in Fig.1
locations = r2unif(500, c(0,100), c(0,100))
T = 3000
locations_distance = numeric(length = T)
locations_cov_reduced = numeric(length = T)
locations_cov_full = numeric(length = T)
s1 = 0;s2 = 0
for(t in 1:T) {
s1 = locations[runif(1, 0, 500), ]
s2 = locations[runif(1, 0, 500), ]
locations_distance[t] = sqrt(sum((s1 - s2)^2))
locations_cov_reduced[t] = C_l(s1, s2)
locations_cov_full[t] = C_full(s1, s2)
}
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_reduced, cex=0.4, col="red")
points(locations_distance, locations_cov_full, cex=0.4, col="green")
## Compare C(h),C_l(h) and C_full(h)
h_matrix = expand.grid(50,0:35)
plot(0:35, apply(h_matrix, 1, trueCovariance, c(50,0)),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
lines(0:35, apply(h_matrix, 1, C_reduced, c(50,0)), col="red")
lines(0:35, apply(h_matrix, 1, C_full, c(50,0)), col="green")
hist(locations_distance)
hist(locations_distance,breaks = 20)
knots_matrix = as.matrix(expand.grid(seq(5, 95, 20),seq(5, 95, 20)))
## knots S*
knots_num = 25
knots_matrix = as.matrix(expand.grid(seq(5, 95, 20),seq(5, 95, 20)))
## C* matrix of size m * m
C_star <- matrix(0, nrow = knots_num, ncol = knots_num)
for(i in 1:knots_num)
for(j in 1:knots_num)
C_star[i,j] = trueCovariance(knots_matrix[i,],knots_matrix[j,])
eigenvalues = eigen(C_star)$values
eigenvectors = eigen(C_star)$vectors
C_star_inv = solve(C_star)
## reduced rank approximation covariance function
C_reduced <- function(s1, s2) {
## reduced rank approximation
vecS1 = apply(knots_matrix, 1, trueCovariance, s1)
vecS2 = apply(knots_matrix, 1, trueCovariance, s2)
## return(t(vecS1) %*% solve(C_star,vecS2))
return(t(vecS1) %*% C_star_inv %*% vecS2)
}
## tapering
## spherical covariance function
sphericalK <- function(h, gamma) max(0,(1-h/gamma)^2) * (1+h/(2*gamma))
generateTapering <- function(K) {
## generate the tapering function
f <- function(s1, s2, gamma) {
distance = sqrt(sum((s1-s2)^2))
return(K(distance ,gamma))
}
}
K <- generateTapering(sphericalK)
## full-scale approximation
C_l <- C_reduced
C_s <- function(s1, s2) {
(trueCovariance(s1, s2) - C_reduced(s1, s2)) * K(s1,s2, gamma = 20)
}
C_full <-  function(s1, s2) C_l(s1, s2) + C_s(s1, s2)
## simulation in Fig.1
locations = r2unif(500, c(0,100), c(0,100))
T = 3000
locations_distance = numeric(length = T)
locations_cov_reduced = numeric(length = T)
locations_cov_full = numeric(length = T)
s1 = 0;s2 = 0
for(t in 1:T) {
s1 = locations[runif(1, 0, 500), ]
s2 = locations[runif(1, 0, 500), ]
locations_distance[t] = sqrt(sum((s1 - s2)^2))
locations_cov_reduced[t] = C_l(s1, s2)
locations_cov_full[t] = C_full(s1, s2)
}
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_reduced, cex=0.4, col="red")
points(locations_distance, locations_cov_full, cex=0.4, col="green")
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_reduced, cex=0.4, col="red")
plot(0:100, expC(0:100),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_reduced, cex=0.4, col="red")
## exponential covariance function
expC <- function(h) exp(-3/50 * h)
generateCovaiance <- function(C) {
## generate an isotropic and stationary covariance function
f <- function(s1, s2) {
distance = sqrt(sum((s1-s2)^2))
return(C(distance))
}
}
## Input: two locations s1, s2
## output: covariance between s1 and s2
trueCovariance <- generateCovaiance(expC)
## knots S*
knots_num = 100
knots_matrix = as.matrix(expand.grid(seq(5, 95, 10),seq(5, 95, 10)))
## C* matrix of size m * m
C_star <- matrix(0, nrow = knots_num, ncol = knots_num)
for(i in 1:knots_num)
for(j in 1:knots_num)
C_star[i,j] = trueCovariance(knots_matrix[i,],knots_matrix[j,])
eigenvalues = eigen(C_star)$values
eigenvectors = eigen(C_star)$vectors
C_star_inv = solve(C_star)
## reduced rank approximation covariance function
C_reduced <- function(s1, s2) {
## reduced rank approximation
vecS1 = apply(knots_matrix, 1, trueCovariance, s1)
vecS2 = apply(knots_matrix, 1, trueCovariance, s2)
## return(t(vecS1) %*% solve(C_star,vecS2))
return(t(vecS1) %*% C_star_inv %*% vecS2)
}
## tapering
## spherical covariance function
sphericalK <- function(h, gamma) max(0,(1-h/gamma)^2) * (1+h/(2*gamma))
generateTapering <- function(K) {
## generate the tapering function
f <- function(s1, s2, gamma) {
distance = sqrt(sum((s1-s2)^2))
return(K(distance ,gamma))
}
}
K <- generateTapering(sphericalK)
## full-scale approximation
C_l <- C_reduced
C_s <- function(s1, s2) {
(trueCovariance(s1, s2) - C_reduced(s1, s2)) * K(s1,s2, gamma = 20)
}
C_full <-  function(s1, s2) C_l(s1, s2) + C_s(s1, s2)
## simulation in Fig.1
locations = r2unif(500, c(0,100), c(0,100))
T = 3000
locations_distance = numeric(length = T)
locations_cov_reduced = numeric(length = T)
locations_cov_full = numeric(length = T)
s1 = 0;s2 = 0
for(t in 1:T) {
s1 = locations[runif(1, 0, 500), ]
s2 = locations[runif(1, 0, 500), ]
locations_distance[t] = sqrt(sum((s1 - s2)^2))
locations_cov_reduced[t] = C_l(s1, s2)
locations_cov_full[t] = C_full(s1, s2)
}
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_reduced, cex=0.4, col="red")
points(locations_distance, locations_cov_full, cex=0.4, col="green")
## Compare C(h),C_l(h) and C_full(h)
h_matrix = expand.grid(50,0:35)
plot(0:35, apply(h_matrix, 1, trueCovariance, c(50,0)),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
lines(0:35, apply(h_matrix, 1, C_reduced, c(50,0)), col="red")
lines(0:35, apply(h_matrix, 1, C_full, c(50,0)), col="green")
## exponential covariance function
expC <- function(h) exp(-3/50 * h)
generateCovaiance <- function(C) {
## generate an isotropic and stationary covariance function
f <- function(s1, s2) {
distance = sqrt(sum((s1 - s2)^2))
return(C(distance))
}
}
## Input: two locations s1, s2
## output: covariance between s1 and s2
trueCovariance <- generateCovaiance(expC)
## knots S*
knots_num = 100
knots_matrix = as.matrix(expand.grid(seq(5, 95, 10),seq(5, 95, 10)))
## C* matrix of size m * m
C_star <- matrix(0, nrow = knots_num, ncol = knots_num)
for(i in 1:knots_num)
for(j in 1:knots_num)
C_star[i, j] = trueCovariance(knots_matrix[i, ],knots_matrix[j, ])
eigenvalues = eigen(C_star)$values
eigenvectors = eigen(C_star)$vectors
C_star_inv = solve(C_star)
## reduced rank approximation covariance function
C_reduced <- function(s1, s2) {
## reduced rank approximation
vecS1 = apply(knots_matrix, 1, trueCovariance, s1)
vecS2 = apply(knots_matrix, 1, trueCovariance, s2)
## return(t(vecS1) %*% solve(C_star,vecS2))
return(t(vecS1) %*% C_star_inv %*% vecS2)
}
## tapering
## spherical covariance function
sphericalK <- function(h, gamma) max(0,(1-h/gamma)^2) * (1+h/(2*gamma))
generateTapering <- function(K) {
## generate the tapering function
f <- function(s1, s2, gamma) {
distance = sqrt(sum((s1-s2)^2))
return(K(distance ,gamma))
}
}
K <- generateTapering(sphericalK)
## full-scale approximation
C_l <- C_reduced
C_s <- function(s1, s2) {
(trueCovariance(s1, s2) - C_reduced(s1, s2)) * K(s1,s2, gamma = 20)
}
C_full <-  function(s1, s2) C_l(s1, s2) + C_s(s1, s2)
## simulation in Fig.1
locations = r2unif(500, c(0,100), c(0,100))
T = 3000
locations_distance = numeric(length = T)
locations_cov_reduced = numeric(length = T)
locations_cov_full = numeric(length = T)
s1 = 0;s2 = 0
for(t in 1:T) {
s1 = locations[runif(1, 0, 500), ]
s2 = locations[runif(1, 0, 500), ]
locations_distance[t] = sqrt(sum((s1 - s2)^2))
locations_cov_reduced[t] = C_l(s1, s2)
locations_cov_full[t] = C_full(s1, s2)
}
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_reduced, cex=0.4, col="red")
points(locations_distance, locations_cov_full, cex=0.4, col="green")
####### Helper functions ########
r2unif <- function(n, range1, range2) {
## 2-d uniform randam vector
var1 = runif(n, range1[1],range1[2])
var2 = runif(n, range2[1],range2[2])
return(as.matrix(cbind(var1, var2)))
}
## exponential covariance function
expC <- function(h) exp(-3/50 * h)
generateCovaiance <- function(C) {
## generate an isotropic and stationary covariance function
f <- function(s1, s2) {
distance = sqrt(sum((s1 - s2)^2))
return(C(distance))
}
}
## Input: two locations s1, s2
## output: covariance between s1 and s2
trueCovariance <- generateCovaiance(expC)
## knots S*
knots_num = 100
knots_matrix = as.matrix(expand.grid(seq(5, 95, 10),seq(5, 95, 10)))
## C* matrix of size m * m
C_star <- matrix(0, nrow = knots_num, ncol = knots_num)
for(i in 1:knots_num)
for(j in 1:knots_num)
C_star[i, j] = trueCovariance(knots_matrix[i, ],knots_matrix[j, ])
eigenvalues = eigen(C_star)$values
eigenvectors = eigen(C_star)$vectors
C_star_inv = solve(C_star)
## reduced rank approximation covariance function
C_reduced <- function(s1, s2) {
## reduced rank approximation
vecS1 = apply(knots_matrix, 1, trueCovariance, s1)
vecS2 = apply(knots_matrix, 1, trueCovariance, s2)
## return(t(vecS1) %*% solve(C_star,vecS2))
return(t(vecS1) %*% C_star_inv %*% vecS2)
}
## tapering
## spherical covariance function
sphericalK <- function(h, gamma) max(0,(1-h/gamma)^2) * (1+h/(2*gamma))
generateTapering <- function(K) {
## generate the tapering function
f <- function(s1, s2, gamma) {
distance = sqrt(sum((s1-s2)^2))
return(K(distance ,gamma))
}
}
K <- generateTapering(sphericalK)
## full-scale approximation
C_l <- C_reduced
C_s <- function(s1, s2) {
(trueCovariance(s1, s2) - C_reduced(s1, s2)) * K(s1,s2, gamma = 20)
}
C_full <-  function(s1, s2) C_l(s1, s2) + C_s(s1, s2)
## simulation in Fig.1
locations = r2unif(500, c(0,100), c(0,100))
T = 3000
locations_distance = numeric(length = T)
locations_cov_reduced = numeric(length = T)
locations_cov_full = numeric(length = T)
s1 = 0;s2 = 0
for(t in 1:T) {
s1 = locations[runif(1, 0, 500), ]
s2 = locations[runif(1, 0, 500), ]
locations_distance[t] = sqrt(sum((s1 - s2)^2))
locations_cov_reduced[t] = C_l(s1, s2)
locations_cov_full[t] = C_full(s1, s2)
}
plot(0:35, expC(0:35),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
points(locations_distance, locations_cov_reduced, cex=0.4, col="red")
points(locations_distance, locations_cov_full, cex=0.4, col="green")
## Compare C(h),C_l(h) and C_full(h)
h_matrix = expand.grid(50,0:35)
plot(0:35, apply(h_matrix, 1, trueCovariance, c(50,0)),"l",
xlab = "Distance between s1 and s2", ylab = "Covariance")
lines(0:35, apply(h_matrix, 1, C_reduced, c(50,0)), col="red")
lines(0:35, apply(h_matrix, 1, C_full, c(50,0)), col="green")
